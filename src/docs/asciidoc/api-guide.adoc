== Reactor RabbitMQ API

[[api-guide-overview]]
=== Overview

This section describes the reactive API for producing and consuming messages using RabbitMQ.
There are two main classes in Reactor RabbitMQ:

. `reactor.rabbitmq.Sender` for publishing messages to RabbitMQ
. `reactor.rabbitmq.Receiver` for consuming messages from RabbitMQ

Full API for Reactor RabbitMQ is available in the link:../api/index.html[javadocs].

The project uses https://github.com/reactor/reactor-core[Reactor Core] to expose a https://github.com/reactive-streams/reactive-streams-jvm["Reactive Streams"] API.


[[api-guide-sender]]
=== Reactive RabbitMQ Sender

Outbound messages are sent to RabbitMQ using `reactor.rabbitmq.Sender`.
A `Sender` is associated with one RabbitMQ `Connection` that is used
to transport messages to the broker. A `Sender` can also manage resources
(exchanges, queues, bindings).

A `Sender` is created with an instance of sender configuration options
`reactor.rabbitmq.SenderOptions`.
The properties of `SenderOptions` contains the `ConnectionFactory` that creates
connections to the broker and some Reactor `Scheduler` used by the `Sender`.

[source,java,indent=0]
--------
include::{test-examples}/ApiGuideSender.java[tag=options-simple]
--------
<1> Specify connection factory
<2> Specify scheduler for resource creation

Note you can control the creation of the `Connection` thanks to the
`connectionSupplier(ConnectionFactory)` method:

[source,java,indent=0]
--------
include::{test-examples}/ApiGuideSender.java[tag=options-connection-supplier]
--------
<1> Specify array of addresses and connection name

In the snippet above the connection can be created from 2 different nodes (useful for
failover) and the connection name is set up.

Once the required options have been configured on the options instance,
a new `Sender` instance can be created with the options already
configured in `senderOptions`.

[source,java,indent=0]
--------
include::{test-examples}/ApiGuideSender.java[tag=instanciation]
--------

The `Sender` is now ready to send messages to RabbitMQ.
At this point, a `Sender` instance has been created,
but no connections to RabbitMQ have been made yet.
The underlying `Connection` instance is created lazily
when a first call is made to create a resource or to send messages.

Let's now create a sequence of messages to send to RabbitMQ.
Each outbound message to be sent to RabbitMQ is represented as a `OutboundMessage`.
An `OutboundMessage` contains routing information (exchange to send to and routing key)
as well as the message itself (properties and body).

A https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux<OutboundMessage>]
of messages is created for sending to RabbitMQ.
For beginners, https://github.com/reactor/lite-rx-api-hands-on[Lite Rx API Hands-on]
provides a hands-on tutorial on using the Reactor classes `Flux` and `Mono`.

[source,java,indent=0]
--------
include::{test-examples}/ApiGuideSender.java[tag=outbound-message-flux]
--------

The code segment above creates a sequence of messages to send to RabbitMQ.
The outbound Flux can now be sent to RabbitMQ using the
`Sender` created earlier.

The code segment below sends the messages to RabbitMQ. The final `subscribe()` in the code block
requests upstream to send the messages to RabbitMQ.

[source,java,indent=0]
--------
include::{test-examples}/ApiGuideSender.java[tag=send-flux]
--------
<1> Reactive send operation for the outbound Flux
<2> If the sending fails, log an error
<3> Subscribe to trigger the actual flow of records from `outboundFlux` to RabbitMQ.

See https://github.com/reactor/reactor-rabbitmq/blob/master/reactor-rabbitmq-samples/src/main/java/reactor/rabbitmq/samples/SampleSender.java[SampleSender]
for a full code listing for a `Sender`.

==== Managing resources (exchanges, queues, and bindings)

The `Sender` is also able to declare and delete AMQP resources the reactive way.
You can learn more about the https://www.rabbitmq.com/tutorials/amqp-concepts.html[AMQP
model on RabbitMQ website].

`Sender` has a `declare*` method for each type of resource
(exchange, binding, and queue) and there's also a respective `*Specification`
class to describe each creation.

[source,java,indent=0]
--------
include::{test-examples}/ApiGuideSender.java[tag=resource-declaration]
--------

Note the `Sender#declare*` methods return their respective AMQP results
wrapped into a `Mono`.

One can also use the `ResourcesSpecification` factory class
with a static import to reduce boilerplate code. Combined with
`Mono` chaining and `Sender#declare` shortcuts, it allows for condensed syntax:

[source,java,indent=0]
-------
include::{test-examples}/ApiGuideSender.java[tag=static-import]
...
include::{test-examples}/ApiGuideSender.java[tag=resource-declaration-static-import,indent=0]
-------

`Sender` has `delete*` and `delete` methods as well. Here is an example with
the short method forms:

[source,java,indent=0]
-------
include::{test-examples}/ApiGuideSender.java[tag=static-import]
...
include::{test-examples}/ApiGuideSender.java[tag=resource-deletion,indent=0]
-------

==== Reliable publishing with publisher confirms

`Sender` offers also the `sendWithPublishConfirms` method to send
messages and receive https://www.rabbitmq.com/confirms.html#publisher-confirms[publisher
confirms] to make sure the broker has taken into account the outbound messages.

[source,java,indent=0]
-------
include::{test-examples}/ApiGuideSender.java[tag=publisher-confirms]
-------

`Sender#sendWithPublishConfirms` returns a `Flux<OutboundMessageResult>`
that can be subscribed to to know that outbound messages
have successfully reached the broker.

==== Threading model

Reactor RabbitMQ configure by default the Java Client to use NIO, i.e. there's only
one thread that deals with IO. This can be changed by specifying a `ConnectionFactory`
in the `SenderOptions`.

The `Sender` uses 2 Reactor's `Scheduler`: one for the subscription when creating the
connection and another one for resources management. The `Sender` defaults
to 2 elastic schedulers, this can be overriden in the `SenderOptions`. The `Sender`
takes care of disposing the default schedulers when closing. If not using the default
schedulers, it's developer's job to dispose schedulers they passed in to the
`SenderOptions`.

==== Closing the `Sender`

When the `Sender` is no longer required, the instance can be closed.
The underlying `Connection` is closed, as well as the default
schedulers if none has been explicitly provided.

[source,java,indent=0]
--------
include::{test-examples}/ApiGuideSender.java[tag=closing]
--------

==== Request/reply

Reactor RabbitMQ supports reactive request/reply. From RabbitMQ documentation:
____

RPC (request/reply) is a popular pattern to implement with a
messaging broker like RabbitMQ. [...] The typical way to do
this is for RPC clients to send requests that are routed to a
long lived (known) server queue. The RPC server(s)
consume requests from this queue and then send replies
to each client using the queue named by the client in the reply-to header.
____

For performance reason, Reactor RabbitMQ builds on top
https://www.rabbitmq.com/direct-reply-to.html[direct reply-to]. The next
snippet shows the usage of the `RpcClient` class:

[source,java,indent=0]
--------
include::{test-examples}/ApiGuideSender.java[tag=rpc]
--------
<1> Create `RpcClient` instance from a `Sender`
<2> Send request and get reply
<3> Close `RpcClient` when done

In the example above, a consumer waits on the `rpc.server.queue` to
process requests. A `RpcClient` is created from a `Sender`, it will
send requests to a given exchange with a given routing key. The `RpcClient`
handles the machinery to send the request and wait on a reply queue the
result processed on the server queue, wrapping everything up with reactive API.
Note a RPC client isn't meant to be used for only 1 request, it can be a long-lived object
handling different requests, as long as they're directed to the same destination (defined
by the exchange and the routing key passed in when the `RpcClient` is created).


[[api-guide-receiver]]
=== Reactive RabbitMQ Receiver

Messages stored in RabbitMQ queues are consumed using the reactive
receiver `reactor.rabbitmq.Receiver`.
Each instance of `Receiver` is associated with a single instance
of `Connection` created by the options-provided `ConnectionFactory`.

A receiver is created with an instance of receiver configuration options
`reactor.rabbitmq.ReceiverOptions`. The properties of `SenderOptions`
contains the `ConnectionFactory` that creates connections to the broker
and a Reactor `Scheduler` used for the connection creation.

[source,java,indent=0]
--------
include::{test-examples}/ApiGuideReceiver.java[tag=options-simple]
--------
<1> Specify connection factory
<2> Specify scheduler for connection creation

Note you can control the creation of the `Connection` thanks to the
`connectionSupplier(ConnectionFactory)` method:

[source,java,indent=0]
--------
include::{test-examples}/ApiGuideReceiver.java[tag=options-connection-supplier]
--------
<1> Specify array of addresses and connection name

In the snippet above the connection can be created from 2 different nodes (useful for
failover) and the connection name is set up.

Once the required configuration options have been configured on the options instance,
a new `Receiver` instance can be created with these options to consume inbound messages.
The code snippet below creates a receiver instance and an inbound `Flux` for the receiver.
The underlying `Connection` and `Consumer` instances are created lazily
later when the inbound `Flux` is subscribed to.

[source,java,indent=0]
--------
include::{test-examples}/ApiGuideReceiver.java[tag=inbound-flux]
--------

The inbound RabbitMQ `Flux` is ready to be consumed.
Each inbound message delivered by the Flux is represented as a
http://www.rabbitmq.com/releases/rabbitmq-java-client/current-javadoc/com/rabbitmq/client/Delivery.html[`Delivery`].

See https://github.com/reactor/reactor-rabbitmq/blob/master/reactor-rabbitmq-samples/src/main/java/reactor/rabbitmq/samples/SampleReceiver.java[`SampleReceiver`]
for a full code listing for a `Receiver`.

==== Consuming options

The `Receiver` class has different flavors of the `receive*` method and each of them
can accept a `ConsumeOptions` instance. Here are the different options:

* `overflowStrategy`: the http://projectreactor.io/docs/core/release/api/reactor/core/publisher/FluxSink.OverflowStrategy.html[`OverflowStrategy`]
used when creating the `Flux` of messages. Default is `BUFFER`.
* `qos`: the prefetch count used when message acknowledgment is enabled. Default is 250.
* `hookBeforeEmitBiFunction`: a `BiFunction<Long, ? super Delivery, Boolean>` to decide
whether a message should be emitted downstream or not. Default is to always emit.
* `stopConsumingBiFunction`: a `BiFunction<Long, ? super Delivery, Boolean>` to decide
whether the flux should be completed after the emission of the message. Default is to never complete.

==== Acknowledgment

`Receiver` has several `receive*` methods that differ on the way consumer are acknowledged
back to the broker. Acknowledgment mode can have profound impacts on performance and memory
consumption.

* `consumeNoAck`: the broker forgets about a message as soon as it has sent it to the consumer.
Use this mode if downstream subscribers are very fast, at least faster than the flow of inbound
messages. Messages will pile up in the JVM process memory if subscribers are not
able to cope with the flow of messages, leading to out-of-memory errors. Note this mode
uses the auto-acknowledgment mode when registering the RabbitMQ `Consumer`.
* `consumeAutoAck`: with this mode, messages are acknowledged right after their arrival,
in the `Flux#doOnNext` callback. This can help to cope with the flow of messages, avoiding
the downstream subscribers to be overwhelmed. Note this mode
*does not use* the auto-acknowledgment mode when registering the RabbitMQ `Consumer`.
In this case, `consumeAutoAck` means messages are automatically acknowledged by the library
in one the `Flux` hooks.
* `consumeManualAck`: this method returns a `Flux<AcknowledgableDelivery>` and messages
must be manually acknowledged or rejected downstream with `AcknowledgableDelivery#ack`
or `AcknowledgableDelivery#nack`, respectively. This mode lets the developer
acknowledge messages in the most efficient way, e.g. by acknowledging several messages
at the same time with `AcknowledgableDelivery#ack(true)` and letting Reactor control
the batch size with one of the `Flux#buffer` methods.

To learn more on how the `ConsumeOptions#qos` setting can impact the behavior
of `Receiver#consumeAutoAck` and `Receiver#consumeManualAck`, have a look at
https://www.rabbitmq.com/blog/2012/05/11/some-queuing-theory-throughput-latency-and-bandwidth/[this
post about queuing theory].

==== Closing the `Receiver`

When the `Receiver` is no longer required, the instance can be closed.
The underlying `Connection` is closed, as well as the default scheduler
if none has been explicitly provided.

[source,java,indent=0]
------
include::{test-examples}/ApiGuideReceiver.java[tag=closing]
------

[[api-guide-advanced-features]]
=== Advanced features

This section covers advanced uses of the Reactor RabbitMQ API.

==== Creating a connection with a custom `Mono`

It is possible to specify only a `ConnectionFactory` for `Sender/ReceiverOptions` and
let Reactor RabbitMQ create connection from this `ConnectionFactory`.
If you want more control over the creation of connections, you can use
`Sender/ReceiverOptions#connectionSupplier(ConnectionFactory)`. This is fine for most cases
and doesn't use any reactive API. Both `Sender` and `Receiver` use internally a `Mono<Connection>`
to open the connection only when needed. It is possible to provide this `Mono<Connection>`
through the appropriate `*Options` class:

[source,java,indent=0]
--------
include::{test-examples}/AdvancedFeatures.java[tag=connection-mono]
--------
<1> Create and configure connection factory
<2> Create `Mono` that creates connection with a name
<3> Create `Mono` that creates connection with a name

Providing your own `Mono<Connection>` lets you take advantage of all the Reactor API
(e.g. for caching).


==== Sharing the same connection between `Sender` and `Receiver`

`Sender` and `Receiver` instances create their own `Connection` but it's possible to use
only one or a few `Connection` instances to be able to use exclusive resources between a `Sender`
and a `Receiver` or simply to control the number of created connections.

Both `SenderOptions` and `ReceiverOptions` have a `connectionMono` method that can encapsulate
any logic to create the `Mono<Connection>` the `Sender` or `Receiver` will end up using. Reactor
RabbitMQ provides a way to share the exact same connection instance from a `Mono<Connection>`:

[source,java,indent=0]
--------
include::{test-examples}/AdvancedFeatures.java[tag=shared-connection]
--------
<1> Create and configure connection factory
<2> Create `Mono` that re-uses the same connection instance
<3> Create sender with connection `Mono`
<4> Create receiver with connection `Mono`

Be aware that closing the first `Sender` or `Receiver` will close the underlying
AMQP connection for all the others.